# Routing with TanStack Router

The AgriTech Platform uses TanStack Router v1 for file-based routing with automatic code splitting and type-safe navigation.

## Overview

TanStack Router provides a modern, type-safe routing solution with automatic route tree generation and excellent developer experience.

**Key Benefits:**
- File-based routing (convention over configuration)
- Type-safe navigation and parameters
- Automatic code splitting
- Built-in loading states and error boundaries
- Route guards and authentication checks
- Search parameter validation

## Route Structure

Routes are defined in the `src/routes/` directory using a file-based naming convention.

### File Naming Conventions

| Pattern | Route Path | Description |
|---------|------------|-------------|
| `index.tsx` | `/` | Root index route |
| `__root.tsx` | N/A | Root layout (wraps all routes) |
| `_authenticated.tsx` | N/A | Layout route (no path segment) |
| `dashboard.tsx` | `/dashboard` | Simple route |
| `settings.profile.tsx` | `/settings/profile` | Nested route (dot notation) |
| `tasks.index.tsx` | `/tasks` | Index of `/tasks` |
| `tasks.calendar.tsx` | `/tasks/calendar` | Child route |
| `$moduleId.tsx` | `/:moduleId` | Dynamic route parameter |

### Directory Structure

```
src/routes/
├── __root.tsx                    # Root layout with providers
├── index.tsx                     # Landing page (/)
├── _authenticated.tsx            # Protected layout wrapper
├── dashboard.tsx                 # /dashboard
├── satellite-analysis.tsx        # /satellite-analysis
├── soil-analysis.tsx             # /soil-analysis
├── employees.tsx                 # /employees
├── day-laborers.tsx              # /day-laborers
├── infrastructure.tsx            # /infrastructure
├── utilities.tsx                 # /utilities
├── profitability.tsx             # /profitability
├── reports.tsx                   # /reports
├── settings.tsx                  # /settings (layout)
├── settings.profile.tsx          # /settings/profile
├── settings.preferences.tsx      # /settings/preferences
├── onboarding.tsx                # /onboarding (layout)
├── onboarding.index.tsx          # /onboarding
├── checkout-success.tsx          # /checkout-success
├── $moduleId.tsx                 # /:moduleId (dynamic)
└── accounting.tsx                # /accounting
```

## Auto-Generated Route Tree

**IMPORTANT:** Never edit `routeTree.gen.ts` manually. It's automatically generated by TanStack Router.

The route tree is generated automatically when you run:
```bash
npm run dev        # Development mode (auto-regenerates)
npm run build      # Production build
```

## Route Registration

### Basic Route

```typescript
// src/routes/dashboard.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/dashboard')({
  component: DashboardComponent,
})

function DashboardComponent() {
  return <div>Dashboard Content</div>
}
```

### Route with Loader

Pre-load data before rendering the component:

```typescript
// src/routes/reports.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/reports')({
  loader: async () => {
    // Fetch data before rendering
    const reports = await fetchReports()
    return { reports }
  },
  component: ReportsComponent,
})

function ReportsComponent() {
  const { reports } = Route.useLoaderData()
  return <div>{/* Render reports */}</div>
}
```

### Dynamic Routes

```typescript
// src/routes/$moduleId.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/$moduleId')({
  component: ModuleView,
})

function ModuleView() {
  const { moduleId } = Route.useParams()
  return <div>Module: {moduleId}</div>
}
```

### Nested Routes with Layouts

**Layout Route** (no path segment, prefix with `_`):

```typescript
// src/routes/_authenticated.tsx
import { createFileRoute, Outlet } from '@tanstack/react-router'

export const Route = createFileRoute('/_authenticated')({
  component: AuthenticatedLayout,
})

function AuthenticatedLayout() {
  return (
    <div className="authenticated-layout">
      <Sidebar />
      <main>
        <Outlet /> {/* Child routes render here */}
      </main>
    </div>
  )
}
```

**Child Routes** inherit the layout:

```typescript
// src/routes/_authenticated/dashboard.tsx
// This route will be wrapped by _authenticated layout
```

## Route Protection

### Authentication Guards

The `_authenticated.tsx` layout uses `beforeLoad` to protect routes:

```typescript
// src/routes/_authenticated.tsx
import { createFileRoute, redirect } from '@tanstack/react-router'

export const Route = createFileRoute('/_authenticated')({
  beforeLoad: async ({ context, location }) => {
    // Check authentication before loading protected routes
    const { user } = await context.auth
    if (!user) {
      throw redirect({
        to: '/login',
        search: {
          redirect: location.href,
        },
      })
    }
  },
  component: AuthenticatedLayout,
})
```

**How It Works:**
1. User navigates to a protected route
2. `beforeLoad` checks authentication status
3. If not authenticated, redirect to `/login` with return URL
4. After login, redirect back to original destination

### Permission-Based Route Protection

Use CASL ability system for fine-grained route protection:

```typescript
import { createFileRoute } from '@tanstack/react-router'
import { withRouteProtection } from '@/lib/casl/routeProtection'

export const Route = createFileRoute('/employees')({
  component: withRouteProtection(
    EmployeesComponent,
    'read',
    'Employee'
  ),
})
```

### Subscription-Based Protection

The `_authenticated` layout also checks subscription status:

```typescript
// Excerpt from _authenticated.tsx
function AuthenticatedLayout() {
  const { subscription } = useSubscription()
  const hasValidSubscription = isSubscriptionValid(subscription)
  const isOnSettingsPage = window.location.pathname.includes('/settings/')

  // Block access if no valid subscription (unless on settings page)
  if (!hasValidSubscription && !isOnSettingsPage && currentOrganization) {
    return <SubscriptionRequired reason="no_subscription" />
  }

  return (
    <div className="flex h-screen">
      <Sidebar />
      <main className="flex-1">
        <Outlet />
      </main>
    </div>
  )
}
```

## Navigation

### Link Component

Type-safe navigation with the `Link` component:

```typescript
import { Link } from '@tanstack/react-router'

function Navigation() {
  return (
    <nav>
      <Link to="/dashboard">Dashboard</Link>
      <Link to="/settings/profile">Profile</Link>
      <Link
        to="/$moduleId"
        params={{ moduleId: 'fruit-trees' }}
      >
        Fruit Trees
      </Link>
    </nav>
  )
}
```

### Programmatic Navigation

Use the `useNavigate` hook:

```typescript
import { useNavigate } from '@tanstack/react-router'

function MyComponent() {
  const navigate = useNavigate()

  const goToDashboard = () => {
    navigate({ to: '/dashboard' })
  }

  const goToModule = (moduleId: string) => {
    navigate({
      to: '/$moduleId',
      params: { moduleId },
    })
  }

  return <button onClick={goToDashboard}>Go to Dashboard</button>
}
```

### Navigation with Search Parameters

```typescript
import { useNavigate } from '@tanstack/react-router'

function SearchComponent() {
  const navigate = useNavigate()

  const searchParcels = (query: string) => {
    navigate({
      to: '/dashboard',
      search: { q: query, filter: 'active' },
    })
  }

  return <input onChange={(e) => searchParcels(e.target.value)} />
}
```

## Route Context

Share data across routes using route context:

```typescript
// __root.tsx
import { createRootRouteWithContext } from '@tanstack/react-router'

interface RouterContext {
  auth: {
    user: User | null
    isAuthenticated: boolean
  }
  queryClient: QueryClient
}

export const Route = createRootRouteWithContext<RouterContext>()({
  component: RootComponent,
})
```

Access context in child routes:

```typescript
// Any child route
export const Route = createFileRoute('/dashboard')({
  beforeLoad: ({ context }) => {
    console.log('User:', context.auth.user)
  },
})
```

## Search Parameters

Type-safe search parameters with validation:

```typescript
import { createFileRoute } from '@tanstack/react-router'
import { z } from 'zod'

const searchSchema = z.object({
  page: z.number().default(1),
  filter: z.enum(['all', 'active', 'archived']).default('all'),
  q: z.string().optional(),
})

export const Route = createFileRoute('/parcels')({
  validateSearch: (search) => searchSchema.parse(search),
  component: ParcelsComponent,
})

function ParcelsComponent() {
  const { page, filter, q } = Route.useSearch()
  // page, filter, and q are fully typed!
  return <div>Page {page}</div>
}
```

## Loading States

TanStack Router provides built-in loading states:

```typescript
export const Route = createFileRoute('/reports')({
  loader: async () => {
    // Simulate slow data fetch
    await new Promise(resolve => setTimeout(resolve, 2000))
    return { data: 'Reports' }
  },
  pendingComponent: () => (
    <div className="flex items-center justify-center">
      <div className="animate-spin h-8 w-8 border-b-2 border-green-500" />
    </div>
  ),
  component: ReportsComponent,
})
```

## Error Boundaries

Handle route-level errors:

```typescript
export const Route = createFileRoute('/dashboard')({
  loader: async () => {
    const data = await fetchData()
    if (!data) {
      throw new Error('Data not found')
    }
    return data
  },
  errorComponent: ({ error }) => (
    <div className="error-container">
      <h2>Error loading dashboard</h2>
      <p>{error.message}</p>
    </div>
  ),
  component: DashboardComponent,
})
```

## Route Hooks

### useParams

Access route parameters:

```typescript
import { useParams } from '@tanstack/react-router'

function ModuleView() {
  const { moduleId } = useParams({ from: '/$moduleId' })
  return <div>Module: {moduleId}</div>
}
```

### useSearch

Access search parameters:

```typescript
import { useSearch } from '@tanstack/react-router'

function ParcelsView() {
  const search = useSearch({ from: '/parcels' })
  const { page, filter } = search
  return <div>Page {page}</div>
}
```

### useNavigate

Navigate programmatically (shown above).

### useLocation

Access current location:

```typescript
import { useLocation } from '@tanstack/react-router'

function BreadcrumbNav() {
  const location = useLocation()
  return <div>Current path: {location.pathname}</div>
}
```

## Common Patterns

### Onboarding Flow

```typescript
// src/routes/onboarding.tsx (layout)
export const Route = createFileRoute('/onboarding')({
  component: OnboardingLayout,
})

// src/routes/onboarding.index.tsx
export const Route = createFileRoute('/onboarding/')({
  component: OnboardingStep1,
})
```

### Settings Pages

```typescript
// src/routes/settings.tsx (layout with tabs)
// src/routes/settings.profile.tsx
// src/routes/settings.preferences.tsx
```

### Module-Based Routes

Dynamic routes for different farm modules:

```typescript
// src/routes/$moduleId.tsx
// Handles routes like:
// - /fruit-trees
// - /vegetables
// - /livestock
```

## Route Organization Tips

1. **Keep routes flat**: Avoid deep nesting when possible
2. **Use layouts**: Share common UI with layout routes (`_authenticated.tsx`)
3. **Colocate data fetching**: Use `loader` for route-specific data
4. **Type-safe parameters**: Always validate search params with Zod
5. **Protect sensitive routes**: Use `beforeLoad` for authentication checks
6. **Error boundaries**: Provide user-friendly error messages

## Best Practices

1. **Never edit `routeTree.gen.ts`**: It's auto-generated
2. **Use `beforeLoad` for auth checks**: Prevents unnecessary renders
3. **Leverage `pendingComponent`**: Show loading states during navigation
4. **Type your search params**: Use Zod schemas for validation
5. **Colocate route logic**: Keep loaders, components, and guards together
6. **Use route context**: Share common data across routes
7. **Test protected routes**: Ensure authentication guards work correctly

## Troubleshooting

### Route not found
- Verify file naming follows conventions
- Check that the route is in `src/routes/` directory
- Restart dev server to regenerate route tree

### Type errors
- Ensure TypeScript is configured correctly
- Verify `@tanstack/react-router` is up to date
- Check that route params and search are properly typed

### Authentication redirect loop
- Check `beforeLoad` logic in `_authenticated.tsx`
- Ensure public routes are not wrapped by authenticated layout
- Verify redirect URL is correct

## Summary

TanStack Router provides a powerful, type-safe routing solution for the AgriTech Platform. By following file-based conventions and leveraging built-in features like loaders, error boundaries, and route guards, you can build robust navigation flows with excellent developer experience.
